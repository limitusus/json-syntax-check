#!/usr/bin/env ruby
# frozen_string_literal: true

require 'find'
require 'json'

# JSON checker calling module
module JSONChecker
  def self.run(argv)
    patterns = argv
    checker = Checker.new(patterns)
    failures = checker.run
    failed_files = failures.map{|entry| entry[0]}.compact
    puts "::set-output name=failed_files::#{JSON.dump(failed_files)}"
    if !failures.empty?
      puts "Files below has/have JSON syntax error (of #{checker.files.length} files)"
      failures.each do |f, h|
        puts "- #{f}: #{h}"
      end
    else
      puts "No file has JSON syntax error (of #{checker.files.length} files)"
    end
    failures.length
  end
end

# JSON checker class
class Checker
  def initialize(patterns)
    @patterns = patterns.map { |pat| Regexp.compile(pat) }
    @files = nil
    @base = ENV.fetch('BASE', '/data/')
    @debug = ENV.fetch('DEBUG', '0') != '0'
  end

  def files
    return @files unless @files.nil?

    @files = []
    Find.find(@base) do |file|
      next unless File.file?(file)

      next unless @patterns.any? { |pat| pat.match?(file) }

      @files << file
    end
    puts "base=#{@base} ptns=#{@patterns} files=#{@files}" if @debug

    @files
  end

  def run
    failures = []
    files.each do |file|
      file, hint = valid_json(file)
      if hint
        failures << [file, hint]
      end
    end
    failures
  end

  def valid_json(file)
    begin
      JSON.parse(File.read(file))
    rescue JSON::ParserError => err
      hint = err.message.lines.first.chomp unless err.message.lines.nil?
      if err.message.lines.length > 1
        hint += "' ..."
      end
      hint ||= 'Unknown JSON parse error'
      return file, hint
    else
      return file, nil
    end
  end
end

exit JSONChecker.run(ARGV)
